/*
Copyright 2020 The cert-manager Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package certificates

import (
	"context"
	"strconv"
	"strings"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	networkingv1beta1 "k8s.io/api/networking/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/utils/pointer"

	"github.com/cert-manager/cert-manager/e2e-tests/framework"
	"github.com/cert-manager/cert-manager/e2e-tests/framework/helper/featureset"
	"github.com/cert-manager/cert-manager/e2e-tests/framework/helper/validation"
	e2eutil "github.com/cert-manager/cert-manager/e2e-tests/util"
	"github.com/cert-manager/cert-manager/internal/controller/feature"
	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
	utilfeature "github.com/cert-manager/cert-manager/pkg/util/feature"
)

var _ = Describe("with issuer type "+s.Name, func() {
	ctx := context.Background()
	f := framework.NewDefaultFramework("certificates")

	sharedIPAddress := "127.0.0.1"

	// Wrap this in a BeforeEach else flags will not have been parsed and
	// f.Config will not be populated at the time that this code is run.
	BeforeEach(func() {
		// Special case Public ACME Servers against being run in the standard
		// e2e tests.
		if strings.Contains(s.Name, "Public ACME Server") && strings.Contains(f.Config.Addons.ACMEServer.URL, "pebble") {
			Skip("Not running public ACME tests against local cluster.")
			return
		}
		if s.completed {
			return
		}
		s.complete(f)

		switch s.HTTP01TestType {
		case "Ingress":
			sharedIPAddress = f.Config.Addons.ACMEServer.IngressIP
		case "Gateway":
			sharedIPAddress = f.Config.Addons.ACMEServer.GatewayIP
			framework.RequireFeatureGate(f, utilfeature.DefaultFeatureGate, feature.ExperimentalGatewayAPISupport)
		}
	})

	s.it(f, "should issue a certificate for a single distinct DNS Name defined by an ingress with annotations", func(issuerRef cmmeta.ObjectReference) {
		if s.HTTP01TestType != "Ingress" {
			// TODO @jakexks: remove this skip once either haproxy or traefik fully support gateway API
			Skip("Skipping ingress-specific as non ingress HTTP-01 solver is in use")
			return
		}
		var certName string
		switch {
		case e2eutil.HasIngresses(f.KubeClientSet.Discovery(), networkingv1.SchemeGroupVersion.String()):
			ingClient := f.KubeClientSet.NetworkingV1().Ingresses(f.Namespace.Name)

			name := "testcert-ingress"
			secretName := "testcert-ingress-tls"

			By("Creating an Ingress with the issuer name annotation set")
			ingress, err := ingClient.Create(context.TODO(), e2eutil.NewIngress(name, secretName, map[string]string{
				"cert-manager.io/issuer":       issuerRef.Name,
				"cert-manager.io/issuer-kind":  issuerRef.Kind,
				"cert-manager.io/issuer-group": issuerRef.Group,
			}, e2eutil.RandomSubdomain(s.DomainSuffix)), metav1.CreateOptions{})
			Expect(err).NotTo(HaveOccurred())
			certName = ingress.Spec.TLS[0].SecretName
		case e2eutil.HasIngresses(f.KubeClientSet.Discovery(), networkingv1beta1.SchemeGroupVersion.String()):
			ingClient := f.KubeClientSet.NetworkingV1beta1().Ingresses(f.Namespace.Name)
			name := "testcert-ingress"
			secretName := "testcert-ingress-tls"

			By("Creating an Ingress with the issuer name annotation set")
			ingress, err := ingClient.Create(context.TODO(), e2eutil.NewV1Beta1Ingress(name, secretName, map[string]string{
				"cert-manager.io/issuer":       issuerRef.Name,
				"cert-manager.io/issuer-kind":  issuerRef.Kind,
				"cert-manager.io/issuer-group": issuerRef.Group,
			}, e2eutil.RandomSubdomain(s.DomainSuffix)), metav1.CreateOptions{})
			Expect(err).NotTo(HaveOccurred())
			certName = ingress.Spec.TLS[0].SecretName
		default:
			Fail("Neither " + networkingv1.SchemeGroupVersion.String() + " nor " + networkingv1beta1.SchemeGroupVersion.String() + " were discovered in the API server")
		}

		By("Waiting for the Certificate to exist...")
		cert, err := f.Helper().WaitForCertificateToExist(f.Namespace.Name, certName, time.Minute)
		Expect(err).NotTo(HaveOccurred())

		By("Waiting for the Certificate to be issued...")
		cert, err = f.Helper().WaitForCertificateReadyAndDoneIssuing(cert, time.Minute*8)
		Expect(err).NotTo(HaveOccurred())

		By("Validating the issued Certificate...")
		err = f.Helper().ValidateCertificate(cert, validation.CertificateSetForUnsupportedFeatureSet(s.UnsupportedFeatures)...)
		Expect(err).NotTo(HaveOccurred())
	}, featureset.OnlySAN)

	s.it(f, "should issue a certificate defined by an ingress with certificate field annotations", func(issuerRef cmmeta.ObjectReference) {
		if s.HTTP01TestType != "Ingress" {
			// TODO @jakexks: remove this skip once either haproxy or traefik fully support gateway API
			Skip("Skipping ingress-specific as non ingress HTTP-01 solver is in use")
			return
		}
		var certName string
		domain := e2eutil.RandomSubdomain(s.DomainSuffix)
		duration := time.Hour * 999
		renewBefore := time.Hour * 111
		revisionHistoryLimit := pointer.Int32(7)
		privateKeyAlgorithm := cmapi.RSAKeyAlgorithm
		privateKeyEncoding := cmapi.PKCS1
		privateKeySize := 4096
		privateKeyRotationPolicy := cmapi.RotationPolicyAlways

		switch {
		case e2eutil.HasIngresses(f.KubeClientSet.Discovery(), networkingv1.SchemeGroupVersion.String()):
			ingClient := f.KubeClientSet.NetworkingV1().Ingresses(f.Namespace.Name)

			name := "testcert-ingress"
			secretName := "testcert-ingress-tls"

			By("Creating an Ingress with annotations for issuerRef and other Certificate fields")
			ingress, err := ingClient.Create(context.TODO(), e2eutil.NewIngress(name, secretName, map[string]string{
				"cert-manager.io/issuer":                      issuerRef.Name,
				"cert-manager.io/issuer-kind":                 issuerRef.Kind,
				"cert-manager.io/issuer-group":                issuerRef.Group,
				"cert-manager.io/common-name":                 domain,
				"cert-manager.io/duration":                    duration.String(),
				"cert-manager.io/renew-before":                renewBefore.String(),
				"cert-manager.io/revision-history-limit":      strconv.FormatInt(int64(*revisionHistoryLimit), 10),
				"cert-manager.io/private-key-algorithm":       string(privateKeyAlgorithm),
				"cert-manager.io/private-key-encoding":        string(privateKeyEncoding),
				"cert-manager.io/private-key-size":            strconv.Itoa(privateKeySize),
				"cert-manager.io/private-key-rotation-policy": string(privateKeyRotationPolicy),
			}, domain), metav1.CreateOptions{})
			Expect(err).NotTo(HaveOccurred())

			certName = ingress.Spec.TLS[0].SecretName
		case e2eutil.HasIngresses(f.KubeClientSet.Discovery(), networkingv1beta1.SchemeGroupVersion.String()):
			ingClient := f.KubeClientSet.NetworkingV1beta1().Ingresses(f.Namespace.Name)

			name := "testcert-ingress"
			secretName := "testcert-ingress-tls"

			By("Creating an Ingress with annotations for issuerRef and other Certificate fields")
			ingress, err := ingClient.Create(context.TODO(), e2eutil.NewV1Beta1Ingress(name, secretName, map[string]string{
				"cert-manager.io/issuer":                      issuerRef.Name,
				"cert-manager.io/issuer-kind":                 issuerRef.Kind,
				"cert-manager.io/issuer-group":                issuerRef.Group,
				"cert-manager.io/common-name":                 domain,
				"cert-manager.io/duration":                    duration.String(),
				"cert-manager.io/renew-before":                renewBefore.String(),
				"cert-manager.io/revision-history-limit":      strconv.FormatInt(int64(*revisionHistoryLimit), 10),
				"cert-manager.io/private-key-algorithm":       string(privateKeyAlgorithm),
				"cert-manager.io/private-key-encoding":        string(privateKeyEncoding),
				"cert-manager.io/private-key-size":            strconv.Itoa(privateKeySize),
				"cert-manager.io/private-key-rotation-policy": string(privateKeyRotationPolicy),
			}, domain), metav1.CreateOptions{})
			Expect(err).NotTo(HaveOccurred())

			certName = ingress.Spec.TLS[0].SecretName
		default:
			Fail("Neither " + networkingv1.SchemeGroupVersion.String() + " nor " + networkingv1beta1.SchemeGroupVersion.String() + " were discovered in the API server")
		}

		By("Waiting for the Certificate to exist...")
		cert, err := f.Helper().WaitForCertificateToExist(f.Namespace.Name, certName, time.Minute)
		Expect(err).NotTo(HaveOccurred())

		By("Waiting for the Certificate to be issued...")
		cert, err = f.Helper().WaitForCertificateReadyAndDoneIssuing(cert, time.Minute*8)
		Expect(err).NotTo(HaveOccurred())

		// Verify that the ingres-shim has translated all the supplied
		// annotations into equivalent Certificate field values
		By("Validating the created Certificate")
		err = f.Helper().ValidateCertificate(
			cert,
			func(certificate *cmapi.Certificate, _ *corev1.Secret) error {
				Expect(certificate.Spec.DNSNames).To(ConsistOf(domain))
				Expect(certificate.Spec.CommonName).To(Equal(domain))
				Expect(certificate.Spec.Duration.Duration).To(Equal(duration))
				Expect(certificate.Spec.RenewBefore.Duration).To(Equal(renewBefore))
				Expect(certificate.Spec.RevisionHistoryLimit).To(Equal(revisionHistoryLimit))
				Expect(certificate.Spec.PrivateKey.Algorithm).To(Equal(privateKeyAlgorithm))
				Expect(certificate.Spec.PrivateKey.Encoding).To(Equal(privateKeyEncoding))
				Expect(certificate.Spec.PrivateKey.Size).To(Equal(privateKeySize))
				Expect(certificate.Spec.PrivateKey.RotationPolicy).To(Equal(privateKeyRotationPolicy))
				return nil
			},
		)
		Expect(err).NotTo(HaveOccurred())

		// Verify that the issuer has preserved all the Certificate values
		// in the signed certificate
		By("Validating the issued Certificate...")
		err = f.Helper().ValidateCertificate(cert, validation.CertificateSetForUnsupportedFeatureSet(s.UnsupportedFeatures)...)
		Expect(err).NotTo(HaveOccurred())
	})

	s.it(f, "Creating a Gateway with annotations for issuerRef and other Certificate fields", func(issuerRef cmmeta.ObjectReference) {
		framework.RequireFeatureGate(f, utilfeature.DefaultFeatureGate, feature.ExperimentalGatewayAPISupport)

		name := "testcert-gateway"
		secretName := "testcert-gateway-tls"
		domain := e2eutil.RandomSubdomain(s.DomainSuffix)
		duration := time.Hour * 999
		renewBefore := time.Hour * 111

		By("Creating a Gateway with annotations for issuerRef and other Certificate fields")
		gw := e2eutil.NewGateway(name, f.Namespace.Name, secretName, map[string]string{
			"cert-manager.io/issuer":       issuerRef.Name,
			"cert-manager.io/issuer-kind":  issuerRef.Kind,
			"cert-manager.io/issuer-group": issuerRef.Group,
			"cert-manager.io/common-name":  domain,
			"cert-manager.io/duration":     duration.String(),
			"cert-manager.io/renew-before": renewBefore.String(),
		}, domain)

		gw, err := f.GWClientSet.GatewayV1beta1().Gateways(f.Namespace.Name).Create(context.TODO(), gw, metav1.CreateOptions{})
		Expect(err).NotTo(HaveOccurred())

		// XXX(Mael): the CertificateRef seems to contain the Gateway name
		// "testcert-gateway" instead of the secretName
		// "testcert-gateway-tls".
		certName := string(gw.Spec.Listeners[0].TLS.CertificateRefs[0].Name)

		By("Waiting for the Certificate to exist...")
		cert, err := f.Helper().WaitForCertificateToExist(f.Namespace.Name, certName, time.Minute)
		Expect(err).NotTo(HaveOccurred())

		By("Waiting for the Certificate to be issued...")
		cert, err = f.Helper().WaitForCertificateReadyAndDoneIssuing(cert, time.Minute*8)
		Expect(err).NotTo(HaveOccurred())

		// Verify that the gateway-shim has translated all the supplied
		// annotations into equivalent Certificate field values
		By("Validating the created Certificate")
		Expect(cert.Spec.DNSNames).To(ConsistOf(domain))
		Expect(cert.Spec.CommonName).To(Equal(domain))
		Expect(cert.Spec.Duration.Duration).To(Equal(duration))
		Expect(cert.Spec.RenewBefore.Duration).To(Equal(renewBefore))
	})
})
